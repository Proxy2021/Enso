import { createHash } from "crypto";
import {
  registerToolTemplate,
  registerToolTemplateDataHint,
  type ToolTemplateCoverageStatus,
} from "./native-tools/registry.js";

export type DomainEvolutionStatus =
  | "queued"
  | "generating_blueprint"
  | "validated"
  | "registered"
  | "requires_review"
  | "failed";

export interface DomainGapSignal {
  cardId: string;
  userMessage: string;
  assistantText: string;
  data: unknown;
}

export interface DomainBlueprint {
  toolFamily: string;
  signatureId: string;
  templateId: string;
  supportedActions: string[];
  coverageStatus: ToolTemplateCoverageStatus;
  requiredDataKeys: string[];
  registrationMode: "auto" | "review";
  notes?: string;
}

export interface DomainEvolutionJob {
  id: string;
  fingerprint: string;
  status: DomainEvolutionStatus;
  signal: DomainGapSignal;
  blueprint?: DomainBlueprint;
  error?: string;
  createdAt: number;
  updatedAt: number;
}

const MAX_JOBS = 120;
const jobs = new Map<string, DomainEvolutionJob>();
const byFingerprint = new Map<string, string>();

function now(): number {
  return Date.now();
}

function sanitizeSlug(input: string): string {
  const base = input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
  return base || "unknown_domain";
}

function stableDataShape(data: unknown): string {
  if (Array.isArray(data)) {
    return `arr:${data.length > 0 ? stableDataShape(data[0]) : "empty"}`;
  }
  if (!data || typeof data !== "object") return typeof data;
  const keys = Object.keys(data as Record<string, unknown>).sort();
  return `obj:${keys.join(",")}`;
}

function extractTopLevelKeys(data: unknown): string[] {
  if (!data || typeof data !== "object" || Array.isArray(data)) return [];
  return Object.keys(data).slice(0, 8);
}

function inferDomainLabel(signal: DomainGapSignal): string {
  const input = `${signal.userMessage} ${signal.assistantText}`.toLowerCase();
  const hints = [
    "calendar",
    "email",
    "finance",
    "stocks",
    "crm",
    "sales",
    "social",
    "travel",
    "inventory",
    "support",
    "analytics",
    "notes",
    "files",
    "project",
  ];
  const matched = hints.find((h) => input.includes(h));
  return sanitizeSlug(matched ?? signal.userMessage.split(/\s+/).slice(0, 4).join("_"));
}

function computeFingerprint(signal: DomainGapSignal): string {
  const hash = createHash("sha1");
  hash.update(signal.userMessage.trim().toLowerCase());
  hash.update("|");
  hash.update(stableDataShape(signal.data));
  return hash.digest("hex");
}

async function requestBlueprint(signal: DomainGapSignal): Promise<DomainBlueprint> {
  const webhook = process.env.ENSO_DOMAIN_EVOLUTION_WEBHOOK_URL?.trim();
  if (webhook) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 25_000);
    try {
      const res = await fetch(webhook, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({
          event: "domain_gap",
          signal: {
            userMessage: signal.userMessage,
            assistantText: signal.assistantText.slice(0, 1200),
            dataShape: stableDataShape(signal.data),
            sampleData: signal.data,
          },
          ask: "Propose tool family/signature/template metadata for registration.",
        }),
        signal: controller.signal,
      });
      if (!res.ok) {
        throw new Error(`webhook returned ${res.status}`);
      }
      const parsed = await res.json() as Partial<DomainBlueprint>;
      if (!parsed.toolFamily || !parsed.signatureId || !parsed.templateId) {
        throw new Error("webhook blueprint missing required fields");
      }
      return {
        toolFamily: sanitizeSlug(parsed.toolFamily),
        signatureId: sanitizeSlug(parsed.signatureId),
        templateId: sanitizeSlug(parsed.templateId),
        supportedActions: parsed.supportedActions?.length ? parsed.supportedActions : ["refresh"],
        coverageStatus: parsed.coverageStatus ?? "partial",
        requiredDataKeys: parsed.requiredDataKeys?.length
          ? parsed.requiredDataKeys
          : extractTopLevelKeys(signal.data),
        registrationMode: parsed.registrationMode ?? "review",
        notes: parsed.notes ?? "Generated by external domain evolution service.",
      };
    } finally {
      clearTimeout(timeout);
    }
  }

  // Fallback local blueprint synthesis: register a partial template signature
  // to make future similar cards route through tool mode while awaiting full tool build.
  const label = inferDomainLabel(signal);
  const requiredDataKeys = extractTopLevelKeys(signal.data);
  return {
    toolFamily: `autogen_${label}`,
    signatureId: `${label}_snapshot`,
    templateId: `autogen-${label}-v1`,
    supportedActions: ["refresh"],
    coverageStatus: "partial",
    requiredDataKeys,
    registrationMode: "auto",
    notes: "Auto-synthesized blueprint; implement backend tools/templates via webhook for full coverage.",
  };
}

function validateBlueprint(blueprint: DomainBlueprint): string[] {
  const issues: string[] = [];
  if (!blueprint.toolFamily) issues.push("missing toolFamily");
  if (!blueprint.signatureId) issues.push("missing signatureId");
  if (!blueprint.templateId) issues.push("missing templateId");
  if (!Array.isArray(blueprint.supportedActions) || blueprint.supportedActions.length === 0) {
    issues.push("supportedActions must be non-empty");
  }
  return issues;
}

function trimStore(): void {
  if (jobs.size <= MAX_JOBS) return;
  const sorted = Array.from(jobs.values()).sort((a, b) => a.createdAt - b.createdAt);
  const overflow = sorted.slice(0, jobs.size - MAX_JOBS);
  for (const item of overflow) {
    jobs.delete(item.id);
    if (byFingerprint.get(item.fingerprint) === item.id) {
      byFingerprint.delete(item.fingerprint);
    }
  }
}

async function processJob(jobId: string): Promise<void> {
  const job = jobs.get(jobId);
  if (!job) return;
  job.status = "generating_blueprint";
  job.updatedAt = now();

  try {
    const blueprint = await requestBlueprint(job.signal);
    const validationIssues = validateBlueprint(blueprint);
    if (validationIssues.length > 0) {
      job.status = "failed";
      job.error = `blueprint validation failed: ${validationIssues.join(", ")}`;
      job.updatedAt = now();
      return;
    }
    job.blueprint = blueprint;
    job.status = "validated";
    job.updatedAt = now();

    if (blueprint.registrationMode === "auto") {
      registerToolTemplate({
        toolFamily: blueprint.toolFamily,
        signatureId: blueprint.signatureId,
        templateId: blueprint.templateId,
        supportedActions: blueprint.supportedActions,
        coverageStatus: blueprint.coverageStatus,
      });
      registerToolTemplateDataHint({
        toolFamily: blueprint.toolFamily,
        signatureId: blueprint.signatureId,
        requiredKeys: blueprint.requiredDataKeys,
      });
      job.status = "registered";
      job.updatedAt = now();
    } else {
      job.status = "requires_review";
      job.updatedAt = now();
    }
  } catch (err) {
    job.status = "failed";
    job.error = err instanceof Error ? err.message : String(err);
    job.updatedAt = now();
  }
}

export function reportDomainGap(signal: DomainGapSignal): string {
  const fingerprint = computeFingerprint(signal);
  const existing = byFingerprint.get(fingerprint);
  if (existing) return existing;

  const id = `evo_${createHash("md5").update(`${fingerprint}:${now()}`).digest("hex").slice(0, 12)}`;
  const createdAt = now();
  const job: DomainEvolutionJob = {
    id,
    fingerprint,
    status: "queued",
    signal,
    createdAt,
    updatedAt: createdAt,
  };
  jobs.set(id, job);
  byFingerprint.set(fingerprint, id);
  trimStore();

  // Fire-and-forget background processing.
  void processJob(id);
  return id;
}

export function getDomainEvolutionJobs(): DomainEvolutionJob[] {
  return Array.from(jobs.values()).sort((a, b) => b.createdAt - a.createdAt);
}

export function getDomainEvolutionJob(jobId: string): DomainEvolutionJob | undefined {
  return jobs.get(jobId);
}

